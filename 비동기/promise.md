# Promise

## 자바스크립트 프로미스 객체 
자바스크립트 `Promise` 객체는 비동기 작업의 최종 완료 또는 실패를 나타내는 `Array`, `Object`처럼 독자적인 객체라고 보면 된다. 
비동기 작업이 끝날 때까지 결과를 기다리는 것이 아니라, 결과를 제공하겠다는 "약속"을 반환하는 의미에서 `Promise`라 명명 지어졌다. 

## 프로미스 객체 기본 사용법 
### 프로미스 객체 생성 
`Promise` 객체를 생성하려면 `new 키워드`와 `Promise` 생성자 함수를 사용하면 된다. 이 때 `Promise` 생성자 안에 두개의 매개변수를 가진 콜백 함수를 넣게 되는데, 첫 번째 인수는 작업이 성공했을 때 `성공(resolve)`임을 알려주는 객체이며, 두 번째 인수는 작업이 실패했을 때 `실패(reject)`임을 알려주는 오류 객체이다.

> `Promise` 생성자 안에 들어가는 콜백 함수를 `executor`라고 한다.

```js
const myPromise = new Promise((reslove, reject) => {
  const data = fetch("서버 URL");
  if (data) {
    reslove(data);
  } else {
    reject("실패");
  }
});
```

위 코드에서 서버로부터 요청하는 비동기 작업이 성공하느냐 실패하느냐 에 따라 매개  변수를 호출하는 것이 나뉘는 것을 볼 수 있다. 만일 작업이 성공한다면 비동기 로직 실행이 참이라는 걸 알려주기 위해 말 그래도 `resolve()` 성공 메소드를 호출한다. 
실패하면 `reject()` 메소드를 호출한다. 


### 프로미스 객체 처리
이렇게 만들어진 `Promise객체`는 비동기 작업이 완료된 이후에 다른 작업을 연결시켜 진행할 수 있다. 작업 결과에 따라 `.then()`, `catch()` 메소드 체이닝을 통해 성공과 실패에 대한 후속 처리를 진행할 수 있다.

만일 처리가 성공하여 프로미스 객체 내부에서 `resolve(data)`를 호출하게 되면, 바로 `then()`으로 이어져 `then 메서드`의 콜백 함수에서 성공에 대한 추가 처리를 진행한다. 

이때 호출한 `resolve()`함수의 매개변수의 값이 `then()`메서드의 콜백 함수 인자로 들어가 `then`메소드 내부에서 프로미스 객체 내부에서 다룬 값을 사용할 수 있게 된다.

반대로 처리가 실패하여 프로미스 객체 내부에서 `reject("Error")`를 호출하게 되면, 바로 `.catch()`로 이어져 `catch` 메서드를 콜백 함수에서 성공에 대한 추가 처리를 진행한다.
```js
myPromise
    .then((value) => { // 성공적으로 수행했을 때 실행될 코드
    	console.log("Data: ", value); // 위에서 return resolve(data)의 data값이 출력된다
    })
    .catch((error) => { // 실패했을 때 실행될 코드
     	console.error(error); // 위에서 return reject("Error")의 "Error"가 출력된다
    })
    .finally(() => { // 성공하든 실패하든 무조건 실행될 코드
    	
    })
```

### 프로미스 함수 등록 
위와 같이 프로미스 객체를 변수에 바로 할당하는 방식을 사용할 수도 있지만, 보통은 다음과 같이 별도로 함수로 감싸서 사용하는 것이 일반적이다.
```js
function myPromise() {
  return new Promise((resolve, reject) => {
    if (/** 성공 조건 */) {
      resolve(/**결과값 */)
    } else {
      reject(/**에러 값 */)
    }
  })
}

myPromise().then((result) => {
  // 성공 시 실행할 함수
}).catch((error) => {
  // 실패 시 실행할 콜백 함수
})
```
함수를 만들고 그 함수를 호출하면 프로미스 생성자를 `return`함으로서, 곧바로 생성된 프로미스 객체를 함수 반환값으로 얻어 사용하는 기법이다. 이렇게 프로미스 객체를 함수로 만드는 이유는 다음 3가지가 있다.
1. 재사용성
- 프로미스 객체를 함수로 만들면 필요할 때마다 호출하여 사용함으로써, 반복되는 비동기 작업을 효율적으로 관리할 수 있다.
2. 가독성
- 프로미스 객체를 함수로 만들면 코드의 구조가 명확져, 비동기 작업의 정의와 사용을 분리하여 코드의 가독성을 높힐 수 있다.
3. 확장성
- 프로미스 객체를 함수로 만들면 인자를 전달하여 동적으로 비동기 작업을 수행할 수 있다. 또한 여러 개의 프로미스 객체를 반환하는 함수들을 연결하여 복잡한 비동기 로직을 구현할 수 있다.

이런 점 때문에 `promise`를 제공할일이 있다면 함수로 감싸 사용한다. 
그래서 대부분의 자바스크립트 비동기 라이브러리도 함수 형태로 프로미스 객체를 제공한다. 
대표적으로 `fetch` 메서드가 있는데, 이 `fetch()`메소드 내에서 프로미스 객체를 생성하여 서버로부터 데이터를 가져오면 `resolve()`하여 `.then()`으로처리하기 때문이다. 
```js
// GET 요청 예시
fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then((response) => response.json()) // 응답 객체에서 JSON 데이터를 추출한다.
  .then((data) => console.log(data)); // JSON 데이터를 콘솔에 출력한다.
```
### 프로미스 3가지 상태
프로미스는 비동기 작업의 결과를 약속하는 것이다. new Promise() 생성자로 프로미스 객체를 생성하면, 그 비동기 작업은 이미 진행 중이고, 언젠가는 성공하거나 실패할 것이다. 
이러한 진행중, 성공, 실패 상태를 나타내는 것이 프로미스의 상태(state)라고 불리운다. 쉽게 말하자면 일종의 프로미스 처리 과정이라고 보면 된다.

1. Pending(대기) : 처리가 완료되지 않은 상태(처리 진행중)
2. Fulfilled (이행) : 성공적으로 처리가 완료된 상태
3. Rejected(거부) : 처리가 실패로 끝난 상태

## 프로미스 정적 메서드
### Promise.resolve()
### Promise.reject()
### Promise.all()
### Promise.allSettled()
### Promise.any()
### Promise.race()


## 참고 문서

출처: [비동기처리](https://inpa.tistory.com/entry/JS-📚-비동기처리-Promise )